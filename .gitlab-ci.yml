# Use stages to define stages that contain groups of jobs. Use stage in a job
# to configure the job to run in a specific stage.
stages:
  - test
  - publish

# Global default environment variables set for all jobs unless overridden by
# job-specific configuration.
variables:
  # Make sure output supports UTF-8
  LC_ALL: "C.UTF-8"
  LANG: "C.UTF-8"

# Global default parameters set for all jobs unless overridden by job-specific
# configuration.
default:
  image: python:3.8
  interruptible: true
  tags:
    - kitware

###############################################################################
# Run Conditions
#
# In the future, this could be broken out into a separate file that we
# `include` here.
#
# REMINDER: The "." prefix causes the "job" to be hidden (does not get run),
# but can still be used for inheritance.

# Run rules to activate at the major junction points: merge requests, tag
# pipelines and branch pipelines for main.
.run_automatically:
  rules:
    # If changes are make to an active merge request.
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    # If changes are pushed for a tag.
    - if: $CI_COMMIT_TAG
      when: on_success
    # If changes are pushed to the default branch.
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never  # explicit fail-exclude terminal condition.

# Run rule to trigger on a tag push/update that matches our expected release
# versioning pattern.
.run_on_upstream_version_tag:
  rules:
    # If changes are pushed for a tag and the tag matching the release version
    # pattern. Also checking that the repository is the official upstream
    # source.
    #- if: $CI_COMMIT_TAG =~ /^v\d+(\.\d+)*$/ && $CI_SERVER_HOST == "gitlab.jatic.net" && $CI_PROJECT_NAMESPACE == "jatic/kitware"
    - if: $CI_COMMIT_TAG =~ /^X\d+(\.\d+)*$/ && $CI_SERVER_HOST == "gitlab.jatic.net" && $CI_PROJECT_NAMESPACE == "jatic/kitware"
      when: on_success
    - when: never  # explicit fail-exclude terminal condition.

###############################################################################
# Jobs -- Testing
#
# In the future, `.`-prefixed templates could be broken out into a separate
# file that we `include` here.
#
# REMINDER: The "." prefix causes the "job" to be hidden (does not get run),
# but can still be used for inheritance.

# For internal git dependencies
.setup_ci_git: &setup_ci_git
  - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.jatic.net".insteadof "ssh://git@gitlab.jatic.net"
  - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.jatic.net/".insteadOf "git@gitlab.jatic.net:"

.setup_poetry:
  variables:
    # Change pip's cache directory to be inside the project directory since we
    # can only cache local items. Same for poetry cache
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  cache:
    # We are only caching the pip cache, NOT THE VENV. Caches should be
    # python version agnostic.
    - key: py-package-cache
      paths:
        - $PIP_CACHE_DIR
  before_script:
    - export PATH=${HOME}/.local/bin:${PATH}
    # Will make use of .cache/pip
    - pip install --user -U poetry
    - command -v python
    - python --version
    - command -v pip
    - pip --version
    - command -v poetry
    - poetry -V
    - poetry config --local virtualenvs.in-project true
    - *setup_ci_git

.poetry_install:
  extends:
    - .setup_poetry
  variables:
    # Change poetry's cache directory to be inside the project directory since
    # we can only cache local items. Same for poetry cache
    POETRY_CACHE_DIR: "$CI_PROJECT_DIR/.cache/poetry"
  cache:
    # We are only caching the poetry cache, NOT THE VENV. Caches should be
    # python version agnostic.
    - !reference [.setup_poetry, cache]
    - key: py-poetry-cache
      paths:
        - $POETRY_CACHE_DIR
  before_script:
    - !reference [.setup_poetry, before_script]
    # Will make use of .cache/poetry
    - poetry install --sync

.test_preamble:
  extends:
    - .run_automatically
  stage: test
  # Note: usage of default image/interruptable/tags

.test_defaults:
  extends:
    - .test_preamble
    - .poetry_install

# Job to ensure the provided example script still runs
test-pytest:
  extends: .test_defaults
  parallel:
    matrix:
      - PY_VERSION: [ "3.8", "3.9", "3.10", "3.11" ]
  image: python:${PY_VERSION}
  script:
    - poetry run pip uninstall -qy opencv-python opencv-python-headless
    - poetry run pip install -q opencv-python-headless
    - poetry run python examples/pybsm_example.py
    - ls examples/fig_2.png
    - ls examples/fig_4a.png
    - ls examples/fig_5a.png
    - ls examples/fig_showcase.png

###############################################################################
# Jobs -- Publishing
#
# Jobs related to automation around publishing our package.before_script:
#

# When a tag is created matching the release pattern, build and publish our
# package to PYPI.
publish-on-tag:
  extends:
    - .run_on_upstream_version_tag
    - .setup_poetry
  # Note: using of default image/interruptable/tags
  stage: publish
  script:
    # Ensure there is alignment with the tag reference and the reported
    # version of the package
    - |
      PACKAGE_VERSION="v$(poetry version -s)"
      if [[ "${CI_COMMIT_TAG}" != "${PACKAGE_VERSION}" ]]
      then
        echo "ERROR: Git tag reference and package version are NOT synonymous."
        echo "       Package version: ${PACKAGE_VERSION}"
        echo "       Git ref name   : ${CI_COMMIT_TAG}"
        exit 1
      fi
    # Ensure that we have token
    - |
      if [[ -z "${PYPI_PUBLISH_TOKEN}" ]]
      then
        echo "ERROR: Expected PYPI token variable was blank."
        echo "       Did you forget to set the appropriate PYPI_PUBLISH_TOKEN secret?"
        exit 1
      fi
    # Actually publish
    - |
      export POETRY_PYPI_TOKEN_PYPI="${PYPI_PUBLISH_TOKEN}"
      poetry publish --build
